#!/usr/bin/env -S uv run --script
# /// script
# dependencies = [
#   "blessed >= 1.21.0",
#   "ptyprocess >= 0.7.0",
#   "pyte >= 0.8.1",
# ]
# ///
"""
Shell Capture - A robust TUI wrapper with a true 2D screen buffer.

Final version with fixes for nested TUI color rendering and performance.
"""

import os
import select
import signal
import sys
import termios
import re
import math
import subprocess
import time
import logging
from itertools import product, islice
from typing import Dict, List, Optional

import blessed
import ptyprocess
import pyte
from pyte import screens as pyte_screens


# --- MONKEY-PATCH FOR PYTE/VIM COMPATIBILITY ---
# This patch fixes a TypeError when running complex TUI apps like Vim
# by making `select_graphic_rendition` accept an unexpected `private` kwarg.
original_sgr = pyte.screens.Screen.select_graphic_rendition


def patched_select_graphic_rendition(self, *args, **kwargs):
    kwargs.pop("private", None)
    return original_sgr(self, *args, **kwargs)


pyte.screens.Screen.select_graphic_rendition = patched_select_graphic_rendition
# --- END OF MONKEY-PATCH ---


# --- Logging Configuration ---
def setup_logging():
    """Setup detailed logging for debugging terminal emulation issues."""
    logger = logging.getLogger("shell_capture")
    
    # Check DEBUG environment variable to set log level
    debug_env = os.environ.get("DEBUG", "").lower()
    if debug_env in ("1", "true", "yes", "on"):
        log_level = logging.DEBUG
    else:
        log_level = logging.INFO
    
    logger.setLevel(log_level)

    # Create file handler for debug.log
    handler = logging.FileHandler("debug.log", mode="w")
    handler.setLevel(logging.DEBUG)

    # Create detailed formatter
    formatter = logging.Formatter(
        "%(asctime)s.%(msecs)03d [%(levelname)s] %(name)s: %(message)s",
        datefmt="%H:%M:%S",
    )
    handler.setFormatter(formatter)

    # Add handler to logger
    logger.addHandler(handler)

    return logger


# Global logger instance
logger = setup_logging()


# --- Global Color Configuration (Gruvbox Style) ---
class GruvboxColors:
    """Gruvbox color palette."""
    # Dark theme colors
    BG = "#282828"
    BG_SOFT = "#32302f"
    BG_HARD = "#1d2021"
    BG1 = "#3c3836"
    BG2 = "#504945"
    BG3 = "#665c54"
    BG4 = "#7c6f64"

    FG = "#ebdbb2"
    FG0 = "#fbf1c7"
    FG1 = "#ebdbb2"
    FG2 = "#d5c4a1"
    FG3 = "#bdae93"
    FG4 = "#a89984"

    # Bright colors
    RED = "#fb4934"
    GREEN = "#b8bb26"
    YELLOW = "#fabd2f"
    BLUE = "#83a598"
    PURPLE = "#d3869b"
    AQUA = "#8ec07c"
    ORANGE = "#fe8019"

    # Neutral colors
    RED_DIM = "#cc241d"
    GREEN_DIM = "#98971a"
    YELLOW_DIM = "#d79921"
    BLUE_DIM = "#458588"
    PURPLE_DIM = "#b16286"
    AQUA_DIM = "#689d6a"
    ORANGE_DIM = "#d65d0e"


class ColorConfig:
    """Color configuration for UI components using Gruvbox theme."""

    # Match highlighting
    MATCH_HIGHLIGHT_BG = GruvboxColors.BLUE_DIM

    # Hint system colors
    HINT_DEFAULT_FG = GruvboxColors.BG
    HINT_DEFAULT_BG = GruvboxColors.YELLOW
    HINT_TYPED_FG = GruvboxColors.FG0
    HINT_TYPED_BG = GruvboxColors.RED
    HINT_PENDING_FG = GruvboxColors.BG
    HINT_PENDING_BG = GruvboxColors.YELLOW_DIM
    HINT_INACTIVE_FG = GruvboxColors.BG4
    HINT_INACTIVE_BG = GruvboxColors.BG1

    # Flash message colors
    FLASH_SUCCESS_FG = GruvboxColors.FG0
    FLASH_SUCCESS_BG = GruvboxColors.GREEN_DIM
    FLASH_ERROR_FG = GruvboxColors.FG0
    FLASH_ERROR_BG = GruvboxColors.RED_DIM

    # Status bar colors (higher contrast)
    STATUS_BAR_FG = GruvboxColors.FG0        # Bright white text
    STATUS_BAR_BG = GruvboxColors.BG         # Dark background
    STATUS_BAR_BORDER_FG = GruvboxColors.BG3 # Medium gray border
    STATUS_BAR_INFO_FG = GruvboxColors.YELLOW # Bright yellow for info
    STATUS_BAR_COUNT_FG = GruvboxColors.GREEN # Bright green for counts


# --- Configuration and Constants ---
DEFAULT_SHELL = os.environ.get("SHELL", "/bin/bash")
CAPTURE_HOTKEY = b"\x05"  # Ctrl+E
ALPHABETS = {"vim-movement": "hjklasdfqwer", "qwerty-homerow": "asdfjklgh"}
DEFAULT_ALPHABET = "vim-movement"
REGEX_PATTERNS = {
    "URL": r"(?:https?://|git@|git://|ssh://|ftp://|file:///)\S+",
    "FILE_PATH": r"(?:[.\w\-@$~\[\]:()][.\w\-@$~\[\]:() ]*[.\w\-@$~\[\]:()]|[.\w\-@$~\[\]:()])?(?:/(?:[.\w\-@$~\[\]:()][.\w\-@$~\[\]:() ]*[.\w\-@$~\[\]:()]|[.\w\-@$~\[\]:()]))+",
    "GIT_COMMIT": r"\b[0-9a-f]{7,40}\b",
    "EMAIL": r"\b[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}\b",
}

# Status bar configuration
STATUS_BAR_ENABLED = True  # Can be configured to disable status bar
STATUS_BAR_HEIGHT = 1  # Height of the status bar in lines


# --- Helper Functions ---
def hex_to_rgb(hex_color: str) -> tuple[int, int, int]:
    """Convert #RRGGBB format hex color string to (r, g, b) tuple."""
    hex_color = hex_color.lstrip("#")
    if len(hex_color) != 6:
        raise ValueError("Invalid hex color format")
    return tuple(int(hex_color[i : i + 2], 16) for i in (0, 2, 4))


def generate_hints(count: int) -> list[str]:
    alphabet = ALPHABETS.get(DEFAULT_ALPHABET, "a")
    a, L = len(alphabet), 1
    if a == 0 and count > 0:
        return []
    if count <= 0:
        return []
    while a**L < count:
        L += 1
    if L == 1:
        return list(alphabet)[:count]
    n_short = math.floor((a**L - count) / (a - 1))
    n_long = count - n_short
    hints = []
    short_gen = ("".join(p) for p in product(alphabet, repeat=L - 1))
    hints.extend(islice(short_gen, n_short))
    long_prefixes = short_gen
    n_long_gen = 0
    for prefix in long_prefixes:
        for char in alphabet:
            if n_long_gen >= n_long:
                break
            hints.append(prefix + char)
            n_long_gen += 1
    return hints


def copy_to_clipboard(text: str) -> bool:
    if not text:
        return False
    try:
        if sys.platform == "darwin":
            cmd = ["pbcopy"]
        else:
            cmd = ["xclip", "-selection", "clipboard"]
        subprocess.run(
            cmd, input=text.encode("utf-8"), check=True, stderr=subprocess.DEVNULL
        )
        return True
    except (FileNotFoundError, subprocess.CalledProcessError):
        return False


# --- UI Components ---
class CaptureUI:
    """
    Interactive hint-based text selection overlay using tmux-capture's pattern matching.

    This class provides the capture mode interface that:
    - Finds text patterns (URLs, file paths, git commits, emails) in screen content
    - Generates vim-friendly hints for each match
    - Provides interactive selection using keyboard input
    - Uses Gruvbox color scheme for visual consistency
    """

    def __init__(
        self, term: blessed.Terminal, plain_lines: List[str], colored_lines: List[str]
    ):
        self.term = term
        self.plain_lines = plain_lines  # Unformatted text for pattern matching
        self.colored_lines = colored_lines  # ANSI-formatted text for display

        # Find all matches and assign hints
        self.matches = self._find_matches()  # List of pattern matches with positions
        self.hints = (
            self._assign_hints()
        )  # Dict mapping hints to representative matches

        # Create content->hint mapping and assign hints to ALL matches
        content_groups = self._group_matches_by_content()
        content_to_hint = {}
        for hint, match_obj in self.hints.items():
            content_to_hint[match_obj["text"]] = hint

        # Assign the same hint to all matches with identical content
        for match in self.matches:
            match["hint"] = content_to_hint[match["text"]]

    def _find_matches(self) -> List[dict]:
        """
        Scan plain text lines for all defined patterns (URLs, paths, commits, emails).

        Returns list of dicts with keys: 'text' (matched content), 'y' (line), 'x' (column)
        """
        found = []
        for i, line in enumerate(self.plain_lines):
            for name, pattern in REGEX_PATTERNS.items():
                for m in re.finditer(pattern, line):
                    found.append({"text": m.group(0), "y": i, "x": m.start()})
        return found

    def _group_matches_by_content(self) -> Dict[str, List[dict]]:
        """
        Group matches by their text content to reduce hint count.
        Same content gets same hint, improving user experience.

        Returns dict mapping text content to list of match objects.
        """
        content_groups = {}
        for match in self.matches:
            content = match["text"]
            if content not in content_groups:
                content_groups[content] = []
            content_groups[content].append(match)
        return content_groups

    def _assign_hints(self) -> Dict[str, dict]:
        """
        Generate vim-friendly hints for unique content, then assign to all matching items.
        This optimization ensures identical content uses the same hint across all instances.

        Returns dict mapping hint strings to match objects for quick lookup.
        """
        # Group matches by content to reduce total hints needed
        content_groups = self._group_matches_by_content()

        # Generate hints only for unique content
        unique_contents = list(content_groups.keys())
        hints = generate_hints(len(unique_contents))
        content_to_hint = dict(zip(unique_contents, hints))

        # Create hint->match mapping, using first match of each content group
        hint_to_match = {}
        for content, hint in content_to_hint.items():
            # Use the first match as the representative for this content
            hint_to_match[hint] = content_groups[content][0]

        return hint_to_match

    def run(self) -> Optional[str]:
        """
        Main interactive loop for hint-based text selection.

        User types hint characters to select matches. Returns selected text or None.
        Supports:
        - Progressive typing: 'a' -> 'as' -> 'asd' to narrow selection
        - Backspace to delete typed characters
        - Escape/Ctrl+C to cancel
        """
        if not self.matches:
            return None  # No patterns found
        current_input = ""
        alphabet = ALPHABETS.get(DEFAULT_ALPHABET, "a")

        with self.term.cbreak(), self.term.hidden_cursor():
            while True:
                self.draw(current_input)  # Render hints with current typing state

                # Check if current input uniquely identifies a hint
                is_prefix = any(
                    h.startswith(current_input) and h != current_input
                    for h in self.hints
                )
                if current_input in self.hints and not is_prefix:
                    return self.hints[current_input]["text"]  # Return the content text

                # Handle keyboard input
                key = self.term.inkey()
                if key.is_sequence:
                    if key.name in ("KEY_ESCAPE", "KEY_CTRL_C"):
                        return None  # Cancel
                    if key.name == "KEY_BACKSPACE":
                        current_input = current_input[:-1]  # Delete char
                elif key and key.lower() in alphabet:
                    # Only accept keys that would lead to valid hints
                    if any(
                        h.startswith(current_input + key.lower()) for h in self.hints
                    ):
                        current_input += key.lower()

    def draw(self, current_input: str):
        """
        Draws the UI with hints overlay using Gruvbox color scheme.

        Shows identical content with the same hint across all instances,
        reducing cognitive load for repeated patterns.
        """
        term = self.term

        # Display colored terminal lines first
        for i, line in enumerate(self.colored_lines):
            print(term.move_xy(0, i) + line + term.clear_eol, end="")

        # Pre-compute terminal style strings using ColorConfig for better performance
        try:
            # Match highlighting style (blue background from Gruvbox)
            highlight_style = term.on_color_rgb(
                *hex_to_rgb(ColorConfig.MATCH_HIGHLIGHT_BG)
            )

            # Hint styles using Gruvbox theme
            style_default = term.color_rgb(
                *hex_to_rgb(ColorConfig.HINT_DEFAULT_FG)
            ) + term.on_color_rgb(*hex_to_rgb(ColorConfig.HINT_DEFAULT_BG))
            style_inactive = (
                term.dim
                + term.color_rgb(*hex_to_rgb(ColorConfig.HINT_INACTIVE_FG))
                + term.on_color_rgb(*hex_to_rgb(ColorConfig.HINT_INACTIVE_BG))
            )
            style_typed_part = (
                term.bold
                + term.color_rgb(*hex_to_rgb(ColorConfig.HINT_TYPED_FG))
                + term.on_color_rgb(*hex_to_rgb(ColorConfig.HINT_TYPED_BG))
            )
            style_pending_part = term.color_rgb(
                *hex_to_rgb(ColorConfig.HINT_PENDING_FG)
            ) + term.on_color_rgb(*hex_to_rgb(ColorConfig.HINT_PENDING_BG))
        except ValueError as e:
            # Fallback to simple colors if hex conversion fails
            highlight_style = term.on_gray20
            style_default = term.on_bright_yellow + term.black
            style_inactive = term.on_gray20 + term.gray70
            style_typed_part = term.on_red + term.bold_white
            style_pending_part = term.on_blue + term.white

        # Highlight all matches with background color
        for match in self.matches:
            print(
                term.move_xy(match["x"], match["y"])
                + highlight_style
                + match["text"]
                + term.normal,
                end="",
            )

        for match in self.matches:
            hint = match.get("hint", "")
            if not hint:
                continue

            hint_display = ""
            if not current_input:
                hint_display = style_default + hint
            elif hint.startswith(current_input):
                typed_len = len(current_input)
                typed_text = hint[:typed_len]
                pending_text = hint[typed_len:]
                hint_display = (
                    style_typed_part + typed_text + style_pending_part + pending_text
                )
            else:
                hint_display = style_inactive + hint

            print(
                term.move_xy(match["x"], match["y"]) + hint_display + term.normal,
                end="",
            )

        sys.stdout.flush()


class ShellCaptureTUI:
    """
    Main TUI application that provides a transparent shell proxy with capture capabilities.

    This class creates a PTY (pseudo-terminal) to run shell commands while providing
    a blessed-based TUI overlay. Key features:
    - Transparent shell interaction (all commands pass through to real shell)
    - Global hotkey (Ctrl+E) triggers capture mode with hint overlays
    - Real-time terminal emulation using pyte library
    - Gruvbox-themed hint system for pattern selection
    """

    def __init__(self, command: str):
        # Core terminal and PTY management
        self.term = blessed.Terminal()  # blessed terminal for TUI rendering
        self.pty_process = None  # PTY process for shell interaction

        # Terminal emulation using pyte library with history support
        # HistoryScreen provides scrollback buffer and better vim compatibility
        # Reserve space for status bar if enabled (reduce by STATUS_BAR_HEIGHT + 1)
        available_height = self.term.height - (STATUS_BAR_HEIGHT if STATUS_BAR_ENABLED else 0)
        self.pyte_screen = pyte_screens.HistoryScreen(
            columns=self.term.width,
            lines=available_height,
            history=1000,  # Keep 1000 lines of scrollback history for terminal restoration
            ratio=0.5,  # Scroll half-screen at a time
        )

        # Store main screen content for alternative screen buffer support
        self.main_screen_content = None
        self.in_alt_screen = False
        self.pyte_stream = pyte.Stream(
            self.pyte_screen
        )  # Processes ANSI escape sequences

        # Application state
        self.command = command  # Shell command to execute
        self.in_capture_mode = False  # Track capture mode state

        # ADDED: Attributes for the flash message feature
        self._flash_message_text: Optional[str] = None
        self._flash_message_expires: float = 0
        self._flash_message_style = ""

        # Status bar attributes
        self._status_bar_enabled = STATUS_BAR_ENABLED
        self._status_message = ""
        self._match_count = 0
        self._temp_status_message = ""  # Temporary message shown in status bar
        self._temp_status_expires = 0
        self._temp_status_style = ""

        # Performance optimization attributes
        self._style_cache = {}  # Cache for computed styles to avoid recalculation
        self._last_render_time = 0  # For render throttling
        self._render_interval = 1.0 / 60.0  # Target 60 FPS (~0.016 seconds)
        self._pending_render = False  # Flag to batch render requests
        self._cache_clear_counter = 0  # Counter for periodic cache clearing

    def _handle_sigwinch(self, signum, frame):
        """Handle terminal window resize events (SIGWINCH signal)."""
        h, w = self.term.height, self.term.width
        # Calculate available height for shell content (excluding status bar)
        available_height = h - (STATUS_BAR_HEIGHT if self._status_bar_enabled else 0)

        if self.pty_process:
            self.pty_process.setwinsize(available_height, w)  # Update PTY dimensions
        self.pyte_screen.resize(lines=available_height, columns=w)  # Update screen buffer size
        # Clear style cache on resize as terminal properties may change
        self._style_cache.clear()
        self._render(full=True)  # Force full screen redraw

    def _handle_sigtstp(self, signum, frame):
        """Handle Ctrl-Y (SIGTSTP) - forward to PTY process for shell to handle."""
        logger.debug("SIGTSTP received - forwarding to PTY process for shell handling")
        logger.debug("SIGNAL_SOURCE: This means Ctrl+Y was processed as SIGNAL, not as raw byte")
        if self.pty_process and self.pty_process.isalive():
            try:
                # Forward SIGTSTP to the shell process in PTY
                os.killpg(self.pty_process.pid, signal.SIGTSTP)
                logger.debug(f"SIGTSTP forwarded to PTY process group {self.pty_process.pid}")
            except (ProcessLookupError, OSError) as e:
                logger.debug(f"Failed to forward SIGTSTP: {e}")

    def _handle_sigcont(self, signum, frame):
        """Handle continuation signal - forward to PTY process."""
        logger.debug("SIGCONT received - forwarding to PTY process")
        if self.pty_process and self.pty_process.isalive():
            try:
                # Forward SIGCONT to the shell process in PTY
                os.killpg(self.pty_process.pid, signal.SIGCONT)
                logger.debug(f"SIGCONT forwarded to PTY process group {self.pty_process.pid}")
            except (ProcessLookupError, OSError) as e:
                logger.debug(f"Failed to forward SIGCONT: {e}")

        # Refresh screen after resume
        self._render(full=True)


    def run(self):
        logger.info(f"=== SHELL_CAPTURE_START: command={self.command} ===")
        logger.debug(f"TERMINAL_SIZE: {self.term.width}x{self.term.height}")

        # Enhanced environment setup for better vim compatibility
        env = os.environ.copy()
        env["TERM"] = "xterm-256color"
        env["COLORTERM"] = "truecolor"
        # Ensure vim recognizes proper terminal capabilities
        env["VIM_TERMINAL"] = "1"
        # Set consistent terminal size (exclude status bar from shell area)
        available_height = self.term.height - (STATUS_BAR_HEIGHT if self._status_bar_enabled else 0)
        env["LINES"] = str(available_height)
        env["COLUMNS"] = str(self.term.width)
        logger.debug(f"ENV_SETUP: TERM={env['TERM']}, COLORTERM={env.get('COLORTERM')}")

        try:
            self.pty_process = ptyprocess.PtyProcess.spawn(
                [DEFAULT_SHELL, "-c", self.command],
                dimensions=(available_height, self.term.width),
                env=env,
            )
            logger.debug(f"PTY_PROCESS_SPAWNED: pid={self.pty_process.pid}")

            # Set proper terminal attributes for vim compatibility
            try:
                # Get current terminal attributes
                attrs = termios.tcgetattr(self.pty_process.fd)

                # Input flags (c_iflag) - enable proper input processing for vim
                attrs[0] |= termios.ICRNL  # Map CR to NL on input
                attrs[0] |= termios.IXON  # Enable XON/XOFF flow control

                # Output flags (c_oflag) - ensure proper output processing
                attrs[1] |= termios.OPOST  # Enable output processing
                attrs[1] |= termios.ONLCR  # Map NL to CR-NL on output

                # Control flags (c_cflag) - already set by ptyprocess

                # Local flags (c_lflag) - configure for interactive applications
                attrs[3] |= termios.ICANON  # Enable canonical mode for line editing
                attrs[3] |= termios.ECHO  # Enable echo (vim needs this)
                attrs[3] |= termios.ECHOE  # Enable erase character echo
                attrs[3] |= termios.ECHOK  # Enable kill character echo
                attrs[3] |= termios.ISIG  # Enable signals (Ctrl+C, etc.)
                attrs[3] &= ~termios.ECHONL  # Disable newline echo when ECHO is off

                termios.tcsetattr(self.pty_process.fd, termios.TCSANOW, attrs)
                logger.debug(
                    "PTY_TERMINAL_ATTRS: configured comprehensive vim compatibility"
                )
            except Exception as attr_e:
                logger.warning(f"PTY_TERMINAL_ATTRS_FAILED: {attr_e}")

        except Exception as e:
            logger.error(f"PTY_SPAWN_FAILED: {e}")
            print(f"Failed to start PTY process: {e}", file=sys.stderr)
            return

        # In raw mode, we still need SIGWINCH for window resize
        signal.signal(signal.SIGWINCH, self._handle_sigwinch)

        # Note: Raw mode disables most signal processing, which is what we want for ZLE
        # Ctrl+Y, Ctrl+O etc will be processed as raw bytes, not signals
        logger.debug("SIGNAL_HANDLER_REGISTERED: SIGWINCH only (raw mode disables other signals)")
        logger.debug("RAW_MODE: All control characters will be processed as raw bytes for ZLE compatibility")

        # Use raw mode for complete control character handling (needed for ZLE)
        try:
            with self.term.fullscreen(), self.term.raw():
                logger.debug("TERMINAL_MODE: fullscreen + raw enabled for complete ZLE compatibility")
                self._main_loop()
        finally:
            logger.debug("CLEANUP: terminating PTY process")
            if self.pty_process and self.pty_process.isalive():
                self.pty_process.terminate(force=True)
            logger.info("=== SHELL_CAPTURE_END ===")

    def _main_loop(self):
        """
        Main event loop that handles bidirectional I/O between user and shell.

        This loop:
        1. Monitors both stdin (user input) and PTY (shell output)
        2. Intercepts Ctrl+E hotkey to trigger capture mode
        3. Forwards all other input transparently to the shell
        4. Processes shell output through pyte for terminal emulation
        """
        pty_fd = self.pty_process.fd
        while self.pty_process.isalive():
            # Check for flash message and temp status expiration
            needs_render = False
            current_time = time.time()

            if self._flash_message_text and current_time > self._flash_message_expires:
                self._flash_message_text = None
                needs_render = True

            if self._temp_status_message and current_time > self._temp_status_expires:
                self._temp_status_message = ""
                needs_render = True

            # Always render if we have status bar or message changes
            should_render = (needs_render or self._pending_render or
                           self.pyte_screen.dirty or self._status_bar_enabled)

            if should_render:
                self._render(full=needs_render)

            # Use select() for non-blocking I/O monitoring with optimized timeout
            try:
                # Adjust timeout based on render interval for better performance
                timeout = min(self._render_interval, 0.1)  # Max 100ms, ideal ~16ms for 60fps
                readable, _, _ = select.select([sys.stdin, pty_fd], [], [], timeout)
            except select.error as e:
                if e.args[0] == 4:
                    continue  # Interrupted system call, retry
                raise

            # Handle user input (keyboard)
            if sys.stdin in readable:
                try:
                    user_input = os.read(sys.stdin.fileno(), 1024)
                    if not user_input:
                        break  # EOF

                    # Log user input with detailed analysis
                    logger.debug(f"USER_INPUT: {repr(user_input)}")

                    # Enhanced control character debugging
                    if len(user_input) == 1 and user_input[0] < 32:
                        ctrl_char = user_input[0]
                        ctrl_name = {
                            1: "Ctrl+A", 2: "Ctrl+B", 3: "Ctrl+C", 4: "Ctrl+D", 5: "Ctrl+E",
                            6: "Ctrl+F", 7: "Ctrl+G", 8: "Ctrl+H", 9: "Ctrl+I", 10: "Ctrl+J",
                            11: "Ctrl+K", 12: "Ctrl+L", 13: "Ctrl+M", 14: "Ctrl+N", 15: "Ctrl+O",
                            16: "Ctrl+P", 17: "Ctrl+Q", 18: "Ctrl+R", 19: "Ctrl+S", 20: "Ctrl+T",
                            21: "Ctrl+U", 22: "Ctrl+V", 23: "Ctrl+W", 24: "Ctrl+X", 25: "Ctrl+Y",
                            26: "Ctrl+Z", 27: "ESC", 28: "Ctrl+\\", 29: "Ctrl+]", 30: "Ctrl+^", 31: "Ctrl+_"
                        }.get(ctrl_char, f"Unknown_Ctrl_{ctrl_char}")
                        logger.debug(f"CONTROL_CHARACTER: {ctrl_name} (byte={ctrl_char}, hex=0x{ctrl_char:02x})")

                        # Special attention to ZLE control characters
                        if ctrl_char in [15, 25]:  # Ctrl+O, Ctrl+Y
                            logger.debug(f"ZLE_CONTROL_CHAR: {ctrl_name} - this should be forwarded to shell for ZLE handling")

                        # Log ALL control characters for debugging
                        logger.debug(f"CTRL_CHAR_DETAILS: {ctrl_name} should map to byte {ctrl_char} (0x{ctrl_char:02x})")

                        # Check if this is being processed as signal vs byte
                        logger.debug(f"PROCESSING_MODE: This control char is being processed as RAW_BYTE (not signal)")
                        logger.debug(f"TERMINAL_MODE: cbreak() mode - some ctrl chars may become signals instead of bytes")
                        logger.debug(f"FORWARDING_DECISION: Will forward this byte directly to PTY for ZLE processing")

                    # Enhanced Enter key handling for vim compatibility
                    if user_input in (b"\r", b"\n", b"\r\n"):
                        logger.debug(
                            f"ENTER_KEY detected: {repr(user_input)} ord_values={[b for b in user_input]}"
                        )
                        # Also log what vim might expect
                        if user_input == b"\n":
                            logger.debug("ENTER_TYPE: LF (Line Feed) - Unix style")
                        elif user_input == b"\r":
                            logger.debug("ENTER_TYPE: CR (Carriage Return) - Mac style")
                        elif user_input == b"\r\n":
                            logger.debug(
                                "ENTER_TYPE: CRLF (Carriage Return + Line Feed) - Windows style"
                            )

                        # Check if we're in alternative screen (vim mode)
                        if self.in_alt_screen:
                            logger.debug(
                                "VIM_ENTER_PROCESSING: In alternative screen, ensuring proper Enter handling"
                            )
                            # For vim compatibility, always ensure we send carriage return
                            if user_input == b"\n":
                                logger.debug(
                                    "VIM_ENTER_CONVERSION: Converting LF to CR for vim compatibility"
                                )
                                # Keep original input but log the conversion attempt

                    elif user_input == b"\x1b":
                        logger.debug("ESCAPE_KEY detected")
                    elif len(user_input) == 1 and user_input[0] < 32:
                        logger.debug(
                            f"CONTROL_KEY detected: ord={user_input[0]} char={repr(user_input)}"
                        )

                    # Log all printable characters for debugging
                    if len(user_input) == 1 and 32 <= user_input[0] <= 126:
                        logger.debug(
                            f"PRINTABLE_KEY detected: {repr(user_input)} char='{user_input.decode()}'"
                        )

                    # Log multi-byte sequences (could be escape sequences)
                    if len(user_input) > 1:
                        logger.debug(
                            f"MULTI_BYTE_INPUT detected: {repr(user_input)} length={len(user_input)}"
                        )
                        # Check if it's an escape sequence
                        if user_input.startswith(b"\x1b"):
                            logger.debug(
                                f"ESCAPE_SEQUENCE detected: {repr(user_input)}"
                            )

                    # Log raw bytes for complete analysis
                    logger.debug(
                        f"RAW_BYTES: {[hex(b) for b in user_input]} decimal={[b for b in user_input]}"
                    )

                    # Special debugging for specific control chars we're looking for
                    if len(user_input) == 1:
                        if user_input[0] == 15:  # Ctrl+O
                            logger.debug("FOUND_CTRL_O: This is the Ctrl+O we're looking for!")
                        elif user_input[0] == 25:  # Ctrl+Y
                            logger.debug("FOUND_CTRL_Y: This is the Ctrl+Y we're looking for!")
                        elif user_input[0] == 14:  # Ctrl+N
                            logger.debug("FOUND_CTRL_N: This might be related to Ctrl+O processing")
                        elif user_input[0] == 79:  # Capital O
                            logger.debug("FOUND_CAPITAL_O: This might be Ctrl+O being processed as Shift+O")

                    # Check for multi-byte sequences that might contain Ctrl+O
                    if b'\x0f' in user_input:  # \x0f is Ctrl+O
                        logger.debug("CTRL_O_IN_SEQUENCE: Found Ctrl+O byte in multi-byte sequence")
                    if b'\x19' in user_input:  # \x19 is Ctrl+Y
                        logger.debug("CTRL_Y_IN_SEQUENCE: Found Ctrl+Y byte in multi-byte sequence")

                    # Check for capture hotkey (Ctrl+E)
                    if CAPTURE_HOTKEY in user_input:
                        logger.debug("CAPTURE_HOTKEY detected - entering capture mode")
                        # Split input around hotkey to preserve other characters
                        prefix, _, suffix = user_input.partition(CAPTURE_HOTKEY)
                        if prefix:
                            logger.debug(f"HOTKEY_PREFIX: {repr(prefix)}")
                            self.pty_process.write(prefix)
                        self._enter_capture_mode()  # Enter hint overlay mode
                        if suffix:
                            logger.debug(f"HOTKEY_SUFFIX: {repr(suffix)}")
                            self.pty_process.write(suffix)
                    else:
                        # Enhanced Enter key handling for vim compatibility
                        processed_input = user_input
                        if user_input in (b"\n", b"\r\n") and self.in_alt_screen:
                            # In vim alternative screen, try different Enter key approaches
                            logger.debug(
                                "VIM_ENTER_ACTUAL_CONVERSION: Trying vim-compatible Enter"
                            )
                            # Method 1: Send CR instead of LF (most common issue)
                            if user_input == b"\n":
                                processed_input = b"\r"
                                logger.debug("VIM_ENTER_METHOD: LF -> CR conversion")
                            # Method 2: Send both CR+LF for maximum compatibility
                            elif user_input == b"\r\n":
                                processed_input = b"\r"  # Simplify to just CR
                                logger.debug("VIM_ENTER_METHOD: CRLF -> CR conversion")
                        elif user_input == b"\r" and self.in_alt_screen:
                            # CR is already correct for vim, keep as-is
                            logger.debug(
                                "VIM_ENTER_METHOD: CR passed through unchanged"
                            )

                        # Forward input (potentially modified) to shell
                        logger.debug(
                            f"FORWARDING_INPUT to PTY: {repr(processed_input)}"
                        )

                        # Additional debug for ZLE control characters
                        if len(processed_input) == 1 and processed_input[0] in [15, 25]:  # Ctrl+O, Ctrl+Y
                            ctrl_name = "Ctrl+O" if processed_input[0] == 15 else "Ctrl+Y"
                            logger.debug(f"ZLE_FORWARD: Sending {ctrl_name} byte to PTY for ZLE processing")
                            logger.debug(f"ZLE_EXPECTATION: Shell should receive this as raw byte and process via ZLE bindings")

                        self.pty_process.write(processed_input)
                except OSError:
                    break

            # Handle shell output
            if pty_fd in readable:
                try:
                    pty_output = self.pty_process.read()
                    if not pty_output:
                        break  # EOF

                    # Decode and log the raw output
                    decoded_output = pty_output.decode("utf-8", "replace")
                    logger.debug(f"PTY_OUTPUT: {repr(decoded_output)}")

                    # Log ANSI escape sequences specifically
                    ansi_sequences = re.findall(
                        r"\x1b\[[?0-9;]*[a-zA-Z]", decoded_output
                    )
                    if ansi_sequences:
                        logger.debug(f"ANSI_SEQUENCES: {ansi_sequences}")

                    # Check for vim mode changes or file opening indicators
                    if "NERD_tree" in decoded_output:
                        logger.debug("VIM_NERDTREE: NERDTree interface detected")
                    if any(
                        pattern in decoded_output
                        for pattern in ["[No Name]", ".log", ".md", ".py"]
                    ):
                        logger.debug(
                            f"VIM_FILE_INDICATOR: Possible file name detected in output"
                        )
                    if "[New File]" in decoded_output or "[readonly]" in decoded_output:
                        logger.debug("VIM_FILE_OPENED: File opening indicator detected")
                    if any(
                        mode in decoded_output
                        for mode in ["-- INSERT --", "-- VISUAL --", "-- NORMAL --"]
                    ):
                        logger.debug(
                            f"VIM_MODE_CHANGE: Mode indicator detected in output"
                        )

                    # Handle alternative screen buffer sequences
                    self._handle_alt_screen_sequences(decoded_output)

                    # Feed output to pyte for terminal emulation
                    self.pyte_stream.feed(decoded_output)

                    # Log screen state changes
                    logger.debug(
                        f"SCREEN_LINES: {self.pyte_screen.lines}, COLUMNS: {self.pyte_screen.columns}"
                    )
                    logger.debug(
                        f"CURSOR_POS: ({self.pyte_screen.cursor.x}, {self.pyte_screen.cursor.y})"
                    )
                    logger.debug(f"DIRTY_LINES: {list(self.pyte_screen.dirty)}")

                except EOFError:
                    logger.debug("PTY_EOF: End of file from PTY process")
                    break

    def _handle_alt_screen_sequences(self, output: str):
        """Handle alternative screen buffer sequences for vim compatibility."""
        # Check for alternative screen buffer enable (\x1b[?1049h)
        if "\x1b[?1049h" in output:
            logger.debug("ALT_SCREEN_ENABLE: Entering alternative screen buffer")
            if not self.in_alt_screen:
                # Save current main screen content
                self.main_screen_content = self._capture_screen_state()
                self.in_alt_screen = True
                logger.debug("ALT_SCREEN_SAVED: Main screen content saved")

        # Check for alternative screen buffer disable (\x1b[?1049l)
        elif "\x1b[?1049l" in output:
            logger.debug("ALT_SCREEN_DISABLE: Exiting alternative screen buffer")
            if self.in_alt_screen and self.main_screen_content:
                # Restore main screen content
                self._restore_screen_state(self.main_screen_content)
                self.in_alt_screen = False
                logger.debug("ALT_SCREEN_RESTORED: Main screen content restored")

    def _capture_screen_state(self) -> dict:
        """Capture current screen state for later restoration."""
        return {
            "display": [
                self.pyte_screen.display[i] for i in range(self.pyte_screen.lines)
            ],
            "buffer": [
                [self.pyte_screen.buffer[y][x] for x in range(self.pyte_screen.columns)]
                for y in range(self.pyte_screen.lines)
            ],
            "cursor_x": self.pyte_screen.cursor.x,
            "cursor_y": self.pyte_screen.cursor.y,
        }

    def _restore_screen_state(self, state: dict):
        """Restore screen state from captured state."""
        try:
            # Clear current screen
            self.pyte_screen.reset()

            # Restore buffer content
            for y in range(min(len(state["buffer"]), self.pyte_screen.lines)):
                for x in range(min(len(state["buffer"][y]), self.pyte_screen.columns)):
                    self.pyte_screen.buffer[y][x] = state["buffer"][y][x]

            # Restore cursor position
            self.pyte_screen.cursor.x = state["cursor_x"]
            self.pyte_screen.cursor.y = state["cursor_y"]

            # Mark all lines as dirty for full redraw
            self.pyte_screen.dirty = set(range(self.pyte_screen.lines))

            logger.debug("SCREEN_STATE_RESTORED: Successfully restored main screen")
        except Exception as e:
            logger.error(f"SCREEN_RESTORE_ERROR: {e}")

    def _pyte_char_to_blessed(self, char: pyte_screens.Char) -> str:
        """
        Translates a pyte.Char's attributes into a blessed style string.
        Optimized version with caching to avoid recalculation.
        """
        # Create a cache key from character attributes
        cache_key = (
            str(char.fg), str(char.bg),
            char.bold, char.italics, char.underscore, char.reverse
        )

        # Check cache first
        if cache_key in self._style_cache:
            return self._style_cache[cache_key]

        style = ""

        pyte_to_blessed_names = {
            "black": "black",
            "red": "red",
            "green": "green",
            "yellow": "yellow",
            "blue": "blue",
            "magenta": "magenta",
            "cyan": "cyan",
            "white": "white",
            "brightblack": "bright_black",
            "brightred": "bright_red",
            "brightgreen": "bright_green",
            "brightyellow": "bright_yellow",
            "brightblue": "bright_blue",
            "brightmagenta": "bright_magenta",
            "brightcyan": "bright_cyan",
            "brightwhite": "bright_white",
            "brown": "yellow",  # FIX: Map 'brown' from pyte to blessed's 'yellow'.
        }

        def is_hex_color(s: str) -> bool:
            if s.startswith("#"):
                s = s[1:]
            return len(s) == 6 and all(c in "0123456789abcdefABCDEF" for c in s)

        # --- Foreground Color ---
        fg = str(char.fg)
        if fg in pyte_to_blessed_names:
            style += getattr(self.term, pyte_to_blessed_names[fg])
        # CORRECTED ORDER: Check for hex color *before* isdigit.
        elif is_hex_color(fg):
            hex_val = fg.lstrip("#")
            r, g, b = (
                int(hex_val[0:2], 16),
                int(hex_val[2:4], 16),
                int(hex_val[4:6], 16),
            )
            style += self.term.color_rgb(r, g, b)
        elif fg.isdigit():
            style += self.term.color(int(fg))

        # --- Background Color ---
        bg = str(char.bg)
        if bg in pyte_to_blessed_names:
            style += getattr(self.term, f"on_{pyte_to_blessed_names[bg]}")
        # CORRECTED ORDER: Check for hex color *before* isdigit.
        elif is_hex_color(bg):
            hex_val = bg.lstrip("#")
            r, g, b = (
                int(hex_val[0:2], 16),
                int(hex_val[2:4], 16),
                int(hex_val[4:6], 16),
            )
            style += self.term.on_color_rgb(r, g, b)
        elif bg.isdigit():
            style += self.term.on_color(int(bg))

        # --- Text Attributes ---
        if char.bold:
            style += self.term.bold
        if char.italics:
            style += self.term.italic
        if char.underscore:
            style += self.term.underline
        if char.reverse:
            style += self.term.reverse

        # Cache the computed style for future use
        self._style_cache[cache_key] = style

        # Periodic cache cleanup to prevent memory growth
        self._cache_clear_counter += 1
        if self._cache_clear_counter > 1000:  # Clear cache every 1000 style computations
            if len(self._style_cache) > 200:  # Keep cache reasonable size
                # Keep only 100 most recently used styles
                items = list(self._style_cache.items())
                self._style_cache = dict(items[-100:])
            self._cache_clear_counter = 0

        return style

    def _render(self, full=False, force=False):
        """Renders the pyte screen to the physical terminal using blessed with throttling."""
        current_time = time.time()

        # Implement render throttling unless forced or full refresh
        if not force and not full:
            if current_time - self._last_render_time < self._render_interval:
                self._pending_render = True  # Mark for later rendering
                return

        self._last_render_time = current_time
        self._pending_render = False

        # Calculate available rendering area (exclude status bar if enabled)
        max_lines = self.pyte_screen.lines
        # Note: pyte_screen.lines already accounts for status bar space
        # so we don't need to subtract again here

        lines_to_draw = (
            range(max_lines) if full else [y for y in self.pyte_screen.dirty if y < max_lines]
        )

        # MODIFIED: A render is also needed if there's a flash message to draw or clear.
        flash_is_active = (
            self._flash_message_text and time.time() < self._flash_message_expires
        )
        # Also check if temp status is active
        temp_status_active = (
            self._temp_status_message and time.time() < self._temp_status_expires
        )
        if not lines_to_draw and not flash_is_active and not temp_status_active and not full:
            if self.pyte_screen.cursor.hidden:
                print(self.term.hide_cursor(), end="")
            else:
                print(
                    self.term.normal_cursor()
                    + self.term.move_xy(
                        self.pyte_screen.cursor.x, self.pyte_screen.cursor.y
                    ),
                    end="",
                )
            sys.stdout.flush()
            return

        with self.term.hidden_cursor():
            # Batch render all lines in one go for better performance
            output_buffer = []

            for y in lines_to_draw:
                line = self.pyte_screen.buffer[y]
                # Map pyte screen coordinates to terminal coordinates
                terminal_y = y  # pyte screen already accounts for available height
                output_line = self.term.move_xy(0, terminal_y)

                # Optimize: process line in chunks of similar styles
                current_style = "UNSET"
                segment = ""
                needs_reset = False

                for x in range(self.pyte_screen.columns):
                    char = line[x]
                    # Skip empty characters optimization
                    if char.data == ' ' and not any([char.bold, char.italics, char.underscore, char.reverse]) and str(char.fg) == 'default' and str(char.bg) == 'default':
                        if current_style != "UNSET":
                            if segment:
                                output_line += self.term.normal + current_style + segment
                            segment = char.data
                            current_style = "UNSET"
                            needs_reset = True
                        else:
                            segment += char.data
                        continue

                    style = self._pyte_char_to_blessed(char)

                    if style != current_style:
                        if segment:
                            if current_style == "UNSET":
                                if needs_reset:
                                    output_line += self.term.normal + segment
                                    needs_reset = False
                                else:
                                    output_line += segment
                            else:
                                output_line += self.term.normal + current_style + segment
                        segment = char.data
                        current_style = style
                    else:
                        segment += char.data

                if segment:
                    if current_style == "UNSET":
                        if needs_reset:
                            output_line += self.term.normal + segment
                        else:
                            output_line += segment
                    else:
                        output_line += self.term.normal + current_style + segment

                output_line += self.term.clear_eol
                output_buffer.append(output_line)

            # Print all lines at once
            print(''.join(output_buffer), end="")

            self.pyte_screen.dirty.clear()

            # Clear the status bar area before rendering (prevent text overlap)
            if self._status_bar_enabled:
                # Clear all lines where status bar will be rendered
                for i in range(STATUS_BAR_HEIGHT):
                    y_pos = self.term.height - STATUS_BAR_HEIGHT + i
                    print(self.term.move_xy(0, y_pos) + self.term.clear_eol, end="")

                # ADDED: Render the status bar
                status_bar_output = self._render_status_bar()
                print(status_bar_output, end="")

            # NOTE: Flash messages are now integrated into status bar
            # No separate flash message rendering needed

        if not self.pyte_screen.cursor.hidden:
            print(
                self.term.normal_cursor()
                + self.term.move_xy(
                    self.pyte_screen.cursor.x, self.pyte_screen.cursor.y
                ),
                end="",
            )
        sys.stdout.flush()

    def _get_rendered_lines(self) -> List[str]:
        """Builds a list of fully rendered, colored screen lines from the pyte buffer with optimizations."""
        rendered_lines = []
        for y in range(self.pyte_screen.lines):
            line = self.pyte_screen.buffer[y]
            output_line = ""
            current_style = "UNSET"
            segment = ""
            needs_reset = False
            for x in range(self.pyte_screen.columns):
                char = line[x]
                # Apply same optimization as main render method
                if char.data == ' ' and not any([char.bold, char.italics, char.underscore, char.reverse]) and str(char.fg) == 'default' and str(char.bg) == 'default':
                    if current_style != "UNSET":
                        if segment:
                            output_line += self.term.normal + current_style + segment
                        segment = char.data
                        current_style = "UNSET"
                        needs_reset = True
                    else:
                        segment += char.data
                    continue

                style = self._pyte_char_to_blessed(char)
                if style != current_style:
                    if segment:
                        if current_style == "UNSET":
                            if needs_reset:
                                output_line += self.term.normal + segment
                                needs_reset = False
                            else:
                                output_line += segment
                        else:
                            output_line += self.term.normal + current_style + segment
                    segment = char.data
                    current_style = style
                else:
                    segment += char.data
            if segment:
                if current_style == "UNSET":
                    if needs_reset:
                        output_line += self.term.normal + segment
                    else:
                        output_line += segment
                else:
                    output_line += self.term.normal + current_style + segment
            rendered_lines.append(output_line)
        return rendered_lines

    def _enter_capture_mode(self):
        """
        Enter capture mode with hint overlays for pattern selection.

        This method:
        1. Captures current screen content (both plain text and styled)
        2. Creates CaptureUI for interactive hint-based selection
        3. Copies selected text to clipboard and shows status feedback
        """
        logger.debug("=== CAPTURE_MODE_START ===")

        # Set capture mode state
        self.in_capture_mode = True

        time.sleep(0.05)  # Brief pause to ensure screen is stable
        self._render(full=True)  # Force complete screen refresh

        # Extract screen content in two formats:
        # 1. Plain text for pattern matching
        plain_lines = [
            self.pyte_screen.display[i].rstrip() for i in range(self.pyte_screen.lines)
        ]
        logger.debug(f"PLAIN_LINES_COUNT: {len(plain_lines)}")
        logger.debug(f"PLAIN_CONTENT_SAMPLE: {repr(plain_lines[:3])}")

        # 2. Colored/styled text for display
        colored_lines = self._get_rendered_lines()
        logger.debug(f"COLORED_LINES_COUNT: {len(colored_lines)}")

        # Launch interactive capture UI
        capture_app = CaptureUI(self.term, plain_lines, colored_lines)
        logger.debug(f"MATCHES_FOUND: {len(capture_app.matches)}")

        # Update match count for status bar (count unique content)
        unique_content = set(match["text"] for match in capture_app.matches)
        self._match_count = len(unique_content)
        logger.debug(f"UNIQUE_MATCHES: {self._match_count}")

        # Force a render to show the updated status bar with match count
        self._render(full=True)

        selected_text = capture_app.run()
        logger.debug(f"SELECTED_TEXT: {repr(selected_text)}")

        # Exit capture mode and restore normal display
        self.in_capture_mode = False
        self._match_count = 0
        self._render(full=True)
        logger.debug("CAPTURE_MODE_SCREEN_RESTORED")

        if selected_text:
            if copy_to_clipboard(selected_text):
                logger.debug(f"CLIPBOARD_SUCCESS: {repr(selected_text[:50])}")
                # Show success message in status bar
                short_text = (
                    (selected_text[:40] + "...")
                    if len(selected_text) > 43
                    else selected_text
                )
                self._set_temp_status(f" Copied: {short_text}", duration=3.0, style_type="success")
            else:
                logger.debug("CLIPBOARD_FAILED")
                self._set_temp_status(" Failed to copy to clipboard", duration=3.0, style_type="error")
        else:
            # Show exit notification when no text was selected
            logger.debug("CAPTURE_MODE_CANCELLED")
            self._set_temp_status("Capture mode exited", duration=1.5, style_type="success")

        logger.debug("=== CAPTURE_MODE_END ===")

    # ADDED: Method to set and trigger a flash message.
    def _flash(self, message: str, duration: float = 1.2, style_type: str = "success"):
        """Sets up a temporary message to be displayed by the render loop."""
        self._flash_message_text = message
        self._flash_message_expires = time.time() + duration

        # Set the style for the message based on success or error
        try:
            if style_type == "success":
                fg, bg = (
                    hex_to_rgb(ColorConfig.FLASH_SUCCESS_FG),
                    hex_to_rgb(ColorConfig.FLASH_SUCCESS_BG),
                )
                self._flash_message_style = self.term.color_rgb(
                    *fg
                ) + self.term.on_color_rgb(*bg)
            else:  # 'error'
                fg, bg = (
                    hex_to_rgb(ColorConfig.FLASH_ERROR_FG),
                    hex_to_rgb(ColorConfig.FLASH_ERROR_BG),
                )
                self._flash_message_style = self.term.color_rgb(
                    *fg
                ) + self.term.on_color_rgb(*bg)
        except (ValueError, AttributeError):  # Fallback to basic colors
            self._flash_message_style = (
                self.term.on_green + self.term.white
                if style_type == "success"
                else self.term.on_red + self.term.white
            )

        self._render()  # Trigger a render to show the message immediately.

    def _render_status_bar(self) -> str:
        """Render vim-style status bar that truly occupies bottom space."""
        if not self._status_bar_enabled:
            return ""

        try:
            # Create styled background with higher contrast
            bg_style = (self.term.color_rgb(*hex_to_rgb(ColorConfig.STATUS_BAR_FG)) +
                       self.term.on_color_rgb(*hex_to_rgb(ColorConfig.STATUS_BAR_BG)))
            info_style = self.term.color_rgb(*hex_to_rgb(ColorConfig.STATUS_BAR_INFO_FG)) + \
                        self.term.on_color_rgb(*hex_to_rgb(ColorConfig.STATUS_BAR_BG))
            count_style = self.term.color_rgb(*hex_to_rgb(ColorConfig.STATUS_BAR_COUNT_FG)) + \
                         self.term.on_color_rgb(*hex_to_rgb(ColorConfig.STATUS_BAR_BG))
        except ValueError:
            # Fallback to basic colors
            bg_style = self.term.on_black + self.term.white
            info_style = self.term.on_black + self.term.bright_yellow
            count_style = self.term.on_black + self.term.bright_green

        width = self.term.width
        # Status bar should always be at the very bottom of terminal
        content_y = self.term.height - 1  # Always at the last line of terminal

        # Conditional debug info based on log level
        debug_line_info = ""
        if logger.isEnabledFor(logging.DEBUG):
            pyte_lines = self.pyte_screen.lines
            terminal_height = self.term.height
            debug_line_info = f"[L{content_y}/H{terminal_height}/P{pyte_lines}]"

        # Check if we have a temporary message to show
        if self._temp_status_message and time.time() < self._temp_status_expires:
            # Show temporary message in status bar
            left_content = f"{debug_line_info} shell-capture "
            middle_content = f" {self._temp_status_message} "
            right_content = f" "
            # Use temp status style if available
            if self._temp_status_style == "error":
                count_style = self.term.color_rgb(*hex_to_rgb(GruvboxColors.RED)) + \
                             self.term.on_color_rgb(*hex_to_rgb(ColorConfig.STATUS_BAR_BG))
        elif self.in_capture_mode:
            # Show match count in capture mode
            unique_count = self._match_count
            left_content = f"{debug_line_info} CAPTURE "
            middle_content = f" {unique_count} matches "
            right_content = f" Press ESC to exit "
        else:
            # Show command info in normal mode
            shell_name = self.command.split()[-1] if self.command != DEFAULT_SHELL else "shell"
            left_content = f"{debug_line_info} shell-capture "
            middle_content = f" {shell_name} "
            right_content = f" Ctrl+E to capture "

        # Calculate positioning for vim-style layout
        left_len = len(left_content)
        right_len = len(right_content)
        middle_len = len(middle_content)
        total_content_len = left_len + middle_len + right_len
        remaining_space = max(0, width - total_content_len)

        # Create multiple lines for status bar based on STATUS_BAR_HEIGHT
        status_lines = []

        for i in range(STATUS_BAR_HEIGHT):
            line_y = self.term.height - STATUS_BAR_HEIGHT + i

            if i == 0:  # First line contains the actual content (top of status bar)
                # Create the content line with proper background fill
                content_line = bg_style  # Start with background
                content_line += info_style + left_content
                content_line += count_style + middle_content
                content_line += bg_style + " " * remaining_space  # Fill middle space
                content_line += info_style + right_content

                # Ensure exact terminal width with background fill
                content_padding = width - (left_len + middle_len + remaining_space + right_len)
                if content_padding > 0:
                    content_line += bg_style + " " * content_padding

                content_line += self.term.normal
                status_lines.append(self.term.move_xy(0, line_y) + content_line)
            else:
                # Fill other lines with background color only
                bg_line = bg_style + " " * width + self.term.normal
                status_lines.append(self.term.move_xy(0, line_y) + bg_line)

        # Return all status bar lines
        return "".join(status_lines)

    def _update_status_message(self, message: str = ""):
        """Update status bar message."""
        self._status_message = message

    def _set_temp_status(self, message: str, duration: float = 2.0, style_type: str = "success"):
        """Set a temporary message in the status bar."""
        self._temp_status_message = message
        self._temp_status_expires = time.time() + duration
        self._temp_status_style = style_type
        self._render()  # Trigger immediate render

    def toggle_status_bar(self):
        """Toggle status bar visibility and adjust screen dimensions."""
        self._status_bar_enabled = not self._status_bar_enabled

        # Recalculate screen dimensions
        h, w = self.term.height, self.term.width
        available_height = h - (STATUS_BAR_HEIGHT if self._status_bar_enabled else 0)

        if self.pty_process:
            self.pty_process.setwinsize(available_height, w)
        self.pyte_screen.resize(lines=available_height, columns=w)

        # Show notification
        status = "enabled" if self._status_bar_enabled else "disabled"
        if self._status_bar_enabled:
            self._set_temp_status(f"Status bar {status}", duration=1.0, style_type="success")

        # Force full redraw
        self._render(full=True)


def main():
    """
    Entry point for shell-capture application.

    Usage:
        shell-capture [command]    # Run specific command in capture wrapper
        shell-capture              # Start default shell in capture wrapper

    Controls:
        Ctrl+E                     # Enter capture mode (hint overlay)
        [hint keys]                # Select pattern in capture mode
        Escape/Ctrl+C              # Exit capture mode
        All other input            # Transparent pass-through to shell

    Features:
        - Status bar showing command info and capture mode status
        - Unique match count display during capture mode
        - Copy success/failure notifications
        - Configurable status bar (enabled by default)
    """
    # Parse command line arguments
    command = " ".join(sys.argv[1:]) if len(sys.argv) > 1 else DEFAULT_SHELL

    logger.info(f"MAIN_START: args={sys.argv}, command={command}")

    # Create and run the TUI application
    app = ShellCaptureTUI(command)
    try:
        app.run()
    except KeyboardInterrupt:
        logger.info("MAIN_INTERRUPTED: KeyboardInterrupt")
        pass  # Clean exit on Ctrl+C
    except Exception as e:
        logger.error(f"MAIN_EXCEPTION: {e}")
        import traceback

        logger.error(f"MAIN_TRACEBACK: {traceback.format_exc()}")
        # Ensure terminal state is restored before printing traceback
        print(blessed.Terminal().normal)
        traceback.print_exc()
    finally:
        logger.info("MAIN_END")
        # ADDED: Print a clear exit message to distinguish from the real terminal.
        term = blessed.Terminal()
        # Use carriage return and newlines to ensure it appears on a fresh line.
        print(f"\r\n{term.green_bold}[shell-capture session ended]{term.normal}\r\n")


if __name__ == "__main__":
    main()
