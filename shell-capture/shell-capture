#!/usr/bin/env -S uv run --script
# /// script
# dependencies = [
#   "blessed >= 1.21.0",
#   "ptyprocess >= 0.7.0",
#   "pyte >= 0.8.1",
# ]
# ///
"""
Shell Capture - A robust TUI wrapper with a true 2D screen buffer.

Final version with fixes for nested TUI color rendering and performance.
"""

import os
import select
import signal
import sys
import termios
import re
import math
import subprocess
import time
import logging
from itertools import product, islice
from typing import Dict, List, Optional

import blessed
import ptyprocess
import pyte
from pyte import screens as pyte_screens


# --- MONKEY-PATCH FOR PYTE/VIM COMPATIBILITY ---
# This patch fixes a TypeError when running complex TUI apps like Vim
# by making `select_graphic_rendition` accept an unexpected `private` kwarg.
original_sgr = pyte.screens.Screen.select_graphic_rendition
def patched_select_graphic_rendition(self, *args, **kwargs):
    kwargs.pop('private', None)
    return original_sgr(self, *args, **kwargs)
pyte.screens.Screen.select_graphic_rendition = patched_select_graphic_rendition
# --- END OF MONKEY-PATCH ---


# --- Logging Configuration ---
def setup_logging():
    """Setup detailed logging for debugging terminal emulation issues."""
    logger = logging.getLogger('shell_capture')
    logger.setLevel(logging.DEBUG)

    # Create file handler for debug.log
    handler = logging.FileHandler('debug.log', mode='w')
    handler.setLevel(logging.DEBUG)

    # Create detailed formatter
    formatter = logging.Formatter(
        '%(asctime)s.%(msecs)03d [%(levelname)s] %(name)s: %(message)s',
        datefmt='%H:%M:%S'
    )
    handler.setFormatter(formatter)

    # Add handler to logger
    logger.addHandler(handler)

    return logger

# Global logger instance
logger = setup_logging()
logger.setLevel(logging.CRITICAL)


# --- Global Color Configuration (Gruvbox Style) ---
class ColorConfig:
    """Color configuration for hint system using Gruvbox theme."""
    MATCH_HIGHLIGHT_BG = "#458588"     # Gruvbox blue background for highlighted matches
    HINT_DEFAULT_FG = "#282828"        # Dark foreground for default hints
    HINT_DEFAULT_BG = "#fabd2f"        # Yellow background for default hints
    HINT_TYPED_FG = "#fbf1c7"          # Light foreground for typed hints
    HINT_TYPED_BG = "#fb4934"          # Red background for typed hints
    HINT_PENDING_FG = "#282828"        # Dark foreground for pending hints
    HINT_PENDING_BG = "#d79921"        # Orange background for pending hints
    HINT_INACTIVE_FG = "#7c6f64"       # Dim foreground for inactive hints
    HINT_INACTIVE_BG = "#3c3836"       # Dark background for inactive hints


# --- Configuration and Constants ---
DEFAULT_SHELL = os.environ.get('SHELL', '/bin/bash')
CAPTURE_HOTKEY = b'\x05'  # Ctrl+E
ALPHABETS = {"vim-movement": "hjklasdfqwer", "qwerty-homerow": "asdfjklgh"}
DEFAULT_ALPHABET = "vim-movement"
REGEX_PATTERNS = {
    "URL": r"(?:https?://|git@|git://|ssh://|ftp://|file:///)\S+",
    "FILE_PATH": r"(?:[.\w\-@$~\[\]]+)?(?:/[.\w\-@$\[\]]+)+",
    "GIT_COMMIT": r"\b[0-9a-f]{7,40}\b",
    "EMAIL": r"\b[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}\b",
}

# --- Helper Functions ---
def hex_to_rgb(hex_color: str) -> tuple[int, int, int]:
    """Convert #RRGGBB format hex color string to (r, g, b) tuple."""
    hex_color = hex_color.lstrip("#")
    if len(hex_color) != 6:
        raise ValueError("Invalid hex color format")
    return tuple(int(hex_color[i : i + 2], 16) for i in (0, 2, 4))

def generate_hints(count: int) -> list[str]:
    alphabet = ALPHABETS.get(DEFAULT_ALPHABET, "a")
    a, L = len(alphabet), 1
    if a == 0 and count > 0: return []
    if count <= 0: return []
    while a**L < count: L += 1
    if L == 1: return list(alphabet)[:count]
    n_short = math.floor((a**L - count) / (a - 1))
    n_long = count - n_short
    hints = []; short_gen = ("".join(p) for p in product(alphabet, repeat=L - 1))
    hints.extend(islice(short_gen, n_short))
    long_prefixes = short_gen; n_long_gen = 0
    for prefix in long_prefixes:
        for char in alphabet:
            if n_long_gen >= n_long: break
            hints.append(prefix + char)
            n_long_gen += 1
    return hints

def copy_to_clipboard(text: str) -> bool:
    if not text: return False
    try:
        if sys.platform == "darwin": cmd = ["pbcopy"]
        else: cmd = ["xclip", "-selection", "clipboard"]
        subprocess.run(cmd, input=text.encode("utf-8"), check=True, stderr=subprocess.DEVNULL)
        return True
    except (FileNotFoundError, subprocess.CalledProcessError): return False

# --- UI Components ---
class CaptureUI:
    """
    Interactive hint-based text selection overlay using tmux-capture's pattern matching.

    This class provides the capture mode interface that:
    - Finds text patterns (URLs, file paths, git commits, emails) in screen content
    - Generates vim-friendly hints for each match
    - Provides interactive selection using keyboard input
    - Uses Gruvbox color scheme for visual consistency
    """
    def __init__(self, term: blessed.Terminal, plain_lines: List[str], colored_lines: List[str]):
        self.term = term
        self.plain_lines = plain_lines    # Unformatted text for pattern matching
        self.colored_lines = colored_lines  # ANSI-formatted text for display

        # Find all matches and assign hints
        self.matches = self._find_matches()    # List of pattern matches with positions
        self.hints = self._assign_hints()      # Dict mapping hints to representative matches

        # Create content->hint mapping and assign hints to ALL matches
        content_groups = self._group_matches_by_content()
        content_to_hint = {}
        for hint, match_obj in self.hints.items():
            content_to_hint[match_obj["text"]] = hint

        # Assign the same hint to all matches with identical content
        for match in self.matches:
            match['hint'] = content_to_hint[match["text"]]

    def _find_matches(self) -> List[dict]:
        """
        Scan plain text lines for all defined patterns (URLs, paths, commits, emails).

        Returns list of dicts with keys: 'text' (matched content), 'y' (line), 'x' (column)
        """
        found = []
        for i, line in enumerate(self.plain_lines):
            for name, pattern in REGEX_PATTERNS.items():
                for m in re.finditer(pattern, line):
                    found.append({"text": m.group(0), "y": i, "x": m.start()})
        return found

    def _group_matches_by_content(self) -> Dict[str, List[dict]]:
        """
        Group matches by their text content to reduce hint count.
        Same content gets same hint, improving user experience.

        Returns dict mapping text content to list of match objects.
        """
        content_groups = {}
        for match in self.matches:
            content = match["text"]
            if content not in content_groups:
                content_groups[content] = []
            content_groups[content].append(match)
        return content_groups

    def _assign_hints(self) -> Dict[str, dict]:
        """
        Generate vim-friendly hints for unique content, then assign to all matching items.
        This optimization ensures identical content uses the same hint across all instances.

        Returns dict mapping hint strings to match objects for quick lookup.
        """
        # Group matches by content to reduce total hints needed
        content_groups = self._group_matches_by_content()

        # Generate hints only for unique content
        unique_contents = list(content_groups.keys())
        hints = generate_hints(len(unique_contents))
        content_to_hint = dict(zip(unique_contents, hints))

        # Create hint->match mapping, using first match of each content group
        hint_to_match = {}
        for content, hint in content_to_hint.items():
            # Use the first match as the representative for this content
            hint_to_match[hint] = content_groups[content][0]

        return hint_to_match

    def run(self) -> Optional[str]:
        """
        Main interactive loop for hint-based text selection.

        User types hint characters to select matches. Returns selected text or None.
        Supports:
        - Progressive typing: 'a' -> 'as' -> 'asd' to narrow selection
        - Backspace to delete typed characters
        - Escape/Ctrl+C to cancel
        """
        if not self.matches: return None  # No patterns found
        current_input = ""
        alphabet = ALPHABETS.get(DEFAULT_ALPHABET, "a")

        with self.term.cbreak(), self.term.hidden_cursor():
            while True:
                self.draw(current_input)  # Render hints with current typing state

                # Check if current input uniquely identifies a hint
                is_prefix = any(h.startswith(current_input) and h != current_input for h in self.hints)
                if current_input in self.hints and not is_prefix:
                    return self.hints[current_input]["text"]  # Return the content text

                # Handle keyboard input
                key = self.term.inkey()
                if key.is_sequence:
                    if key.name in ("KEY_ESCAPE", "KEY_CTRL_C"): return None  # Cancel
                    if key.name == "KEY_BACKSPACE": current_input = current_input[:-1]  # Delete char
                elif key and key.lower() in alphabet:
                    # Only accept keys that would lead to valid hints
                    if any(h.startswith(current_input + key.lower()) for h in self.hints):
                        current_input += key.lower()

    def draw(self, current_input: str):
        """
        Draws the UI with hints overlay using Gruvbox color scheme.

        Shows identical content with the same hint across all instances,
        reducing cognitive load for repeated patterns.
        """
        term = self.term

        # Display colored terminal lines first
        for i, line in enumerate(self.colored_lines):
            print(term.move_xy(0, i) + line + term.clear_eol, end="")

        # Pre-compute terminal style strings using ColorConfig for better performance
        try:
            # Match highlighting style (blue background from Gruvbox)
            highlight_style = term.on_color_rgb(*hex_to_rgb(ColorConfig.MATCH_HIGHLIGHT_BG))

            # Hint styles using Gruvbox theme
            style_default = (term.color_rgb(*hex_to_rgb(ColorConfig.HINT_DEFAULT_FG)) +
                           term.on_color_rgb(*hex_to_rgb(ColorConfig.HINT_DEFAULT_BG)))
            style_inactive = (term.dim +
                            term.color_rgb(*hex_to_rgb(ColorConfig.HINT_INACTIVE_FG)) +
                            term.on_color_rgb(*hex_to_rgb(ColorConfig.HINT_INACTIVE_BG)))
            style_typed_part = (term.bold +
                              term.color_rgb(*hex_to_rgb(ColorConfig.HINT_TYPED_FG)) +
                              term.on_color_rgb(*hex_to_rgb(ColorConfig.HINT_TYPED_BG)))
            style_pending_part = (term.color_rgb(*hex_to_rgb(ColorConfig.HINT_PENDING_FG)) +
                                term.on_color_rgb(*hex_to_rgb(ColorConfig.HINT_PENDING_BG)))
        except ValueError as e:
            # Fallback to simple colors if hex conversion fails
            highlight_style = term.on_gray20
            style_default = term.on_bright_yellow + term.black
            style_inactive = term.on_gray20 + term.gray70
            style_typed_part = term.on_red + term.bold_white
            style_pending_part = term.on_blue + term.white

        # Highlight all matches with background color
        for match in self.matches:
            print(term.move_xy(match['x'], match['y']) + highlight_style + match['text'] + term.normal, end="")

        for match in self.matches:
            hint = match.get("hint", "")
            if not hint:
                continue

            hint_display = ""
            if not current_input:
                hint_display = style_default + hint
            elif hint.startswith(current_input):
                typed_len = len(current_input)
                typed_text = hint[:typed_len]
                pending_text = hint[typed_len:]
                hint_display = style_typed_part + typed_text + style_pending_part + pending_text
            else:
                hint_display = style_inactive + hint

            print(term.move_xy(match['x'], match['y']) + hint_display + term.normal, end="")

        sys.stdout.flush()


class ShellCaptureTUI:
    """
    Main TUI application that provides a transparent shell proxy with capture capabilities.

    This class creates a PTY (pseudo-terminal) to run shell commands while providing
    a blessed-based TUI overlay. Key features:
    - Transparent shell interaction (all commands pass through to real shell)
    - Global hotkey (Ctrl+E) triggers capture mode with hint overlays
    - Real-time terminal emulation using pyte library
    - Gruvbox-themed hint system for pattern selection
    """
    def __init__(self, command: str):
        # Core terminal and PTY management
        self.term = blessed.Terminal()                    # blessed terminal for TUI rendering
        self.pty_process = None                           # PTY process for shell interaction

        # Terminal emulation using pyte library with history support
        # HistoryScreen provides scrollback buffer and better vim compatibility
        self.pyte_screen = pyte_screens.HistoryScreen(
            columns=self.term.width,
            lines=self.term.height,
            history=1000,  # Keep 1000 lines of scrollback history for terminal restoration
            ratio=0.5      # Scroll half-screen at a time
        )

        # Store main screen content for alternative screen buffer support
        self.main_screen_content = None
        self.in_alt_screen = False
        self.pyte_stream = pyte.Stream(self.pyte_screen)  # Processes ANSI escape sequences

        # Application state
        self.command = command                            # Shell command to execute
        self._flash_message_text = None                   # Temporary status message
        self._flash_message_expires = 0                   # Message expiration timestamp

    def _handle_sigwinch(self, signum, frame):
        """Handle terminal window resize events (SIGWINCH signal)."""
        h, w = self.term.height, self.term.width
        if self.pty_process:
            self.pty_process.setwinsize(h, w)             # Update PTY dimensions
        self.pyte_screen.resize(lines=h, columns=w)       # Update screen buffer size
        self._render(full=True)                           # Force full screen redraw

    def run(self):
        logger.info(f"=== SHELL_CAPTURE_START: command={self.command} ===")
        logger.debug(f"TERMINAL_SIZE: {self.term.width}x{self.term.height}")

        # Enhanced environment setup for better vim compatibility
        env = os.environ.copy()
        env["TERM"] = "xterm-256color"
        env["COLORTERM"] = "truecolor"
        # Ensure vim recognizes proper terminal capabilities
        env["VIM_TERMINAL"] = "1"
        # Set consistent terminal size
        env["LINES"] = str(self.term.height)
        env["COLUMNS"] = str(self.term.width)
        logger.debug(f"ENV_SETUP: TERM={env['TERM']}, COLORTERM={env.get('COLORTERM')}")

        try:
            self.pty_process = ptyprocess.PtyProcess.spawn(
                [DEFAULT_SHELL, '-c', self.command],
                dimensions=(self.term.height, self.term.width),
                env=env
            )
            logger.debug(f"PTY_PROCESS_SPAWNED: pid={self.pty_process.pid}")

            # Set proper terminal attributes for vim compatibility
            try:
                # Get current terminal attributes
                attrs = termios.tcgetattr(self.pty_process.fd)

                # Input flags (c_iflag) - enable proper input processing for vim
                attrs[0] |= termios.ICRNL    # Map CR to NL on input
                attrs[0] |= termios.IXON     # Enable XON/XOFF flow control

                # Output flags (c_oflag) - ensure proper output processing
                attrs[1] |= termios.OPOST    # Enable output processing
                attrs[1] |= termios.ONLCR    # Map NL to CR-NL on output

                # Control flags (c_cflag) - already set by ptyprocess

                # Local flags (c_lflag) - configure for interactive applications
                attrs[3] |= termios.ICANON   # Enable canonical mode for line editing
                attrs[3] |= termios.ECHO     # Enable echo (vim needs this)
                attrs[3] |= termios.ECHOE    # Enable erase character echo
                attrs[3] |= termios.ECHOK    # Enable kill character echo
                attrs[3] |= termios.ISIG     # Enable signals (Ctrl+C, etc.)
                attrs[3] &= ~termios.ECHONL  # Disable newline echo when ECHO is off

                termios.tcsetattr(self.pty_process.fd, termios.TCSANOW, attrs)
                logger.debug("PTY_TERMINAL_ATTRS: configured comprehensive vim compatibility")
            except Exception as attr_e:
                logger.warning(f"PTY_TERMINAL_ATTRS_FAILED: {attr_e}")

        except Exception as e:
            logger.error(f"PTY_SPAWN_FAILED: {e}")
            print(f"Failed to start PTY process: {e}", file=sys.stderr)
            return

        signal.signal(signal.SIGWINCH, self._handle_sigwinch)
        logger.debug("SIGNAL_HANDLER_REGISTERED: SIGWINCH")

        with self.term.fullscreen(), self.term.cbreak():
            logger.debug("TERMINAL_MODE: fullscreen + cbreak enabled")
            try:
                self._main_loop()
            finally:
                logger.debug("CLEANUP: terminating PTY process")
                if self.pty_process and self.pty_process.isalive():
                    self.pty_process.terminate(force=True)
                logger.info("=== SHELL_CAPTURE_END ===")

    def _main_loop(self):
        """
        Main event loop that handles bidirectional I/O between user and shell.

        This loop:
        1. Monitors both stdin (user input) and PTY (shell output)
        2. Intercepts Ctrl+E hotkey to trigger capture mode
        3. Forwards all other input transparently to the shell
        4. Processes shell output through pyte for terminal emulation
        """
        pty_fd = self.pty_process.fd
        while self.pty_process.isalive():
            self._render()  # Update screen display

            # Use select() for non-blocking I/O monitoring
            try:
                readable, _, _ = select.select([sys.stdin, pty_fd], [], [], 0.01)
            except select.error as e:
                if e.args[0] == 4: continue  # Interrupted system call, retry
                raise

            # Handle user input (keyboard)
            if sys.stdin in readable:
                try:
                    user_input = os.read(sys.stdin.fileno(), 1024)
                    if not user_input: break  # EOF

                    # Log user input with detailed analysis
                    logger.debug(f"USER_INPUT: {repr(user_input)}")

                    # Enhanced Enter key handling for vim compatibility
                    if user_input in (b'\r', b'\n', b'\r\n'):
                        logger.debug(f"ENTER_KEY detected: {repr(user_input)} ord_values={[b for b in user_input]}")
                        # Also log what vim might expect
                        if user_input == b'\n':
                            logger.debug("ENTER_TYPE: LF (Line Feed) - Unix style")
                        elif user_input == b'\r':
                            logger.debug("ENTER_TYPE: CR (Carriage Return) - Mac style")
                        elif user_input == b'\r\n':
                            logger.debug("ENTER_TYPE: CRLF (Carriage Return + Line Feed) - Windows style")

                        # Check if we're in alternative screen (vim mode)
                        if self.in_alt_screen:
                            logger.debug("VIM_ENTER_PROCESSING: In alternative screen, ensuring proper Enter handling")
                            # For vim compatibility, always ensure we send carriage return
                            if user_input == b'\n':
                                logger.debug("VIM_ENTER_CONVERSION: Converting LF to CR for vim compatibility")
                                # Keep original input but log the conversion attempt

                    elif user_input == b'\x1b':
                        logger.debug("ESCAPE_KEY detected")
                    elif len(user_input) == 1 and user_input[0] < 32:
                        logger.debug(f"CONTROL_KEY detected: ord={user_input[0]} char={repr(user_input)}")

                    # Log all printable characters for debugging
                    if len(user_input) == 1 and 32 <= user_input[0] <= 126:
                        logger.debug(f"PRINTABLE_KEY detected: {repr(user_input)} char='{user_input.decode()}'")

                    # Log multi-byte sequences (could be escape sequences)
                    if len(user_input) > 1:
                        logger.debug(f"MULTI_BYTE_INPUT detected: {repr(user_input)} length={len(user_input)}")
                        # Check if it's an escape sequence
                        if user_input.startswith(b'\x1b'):
                            logger.debug(f"ESCAPE_SEQUENCE detected: {repr(user_input)}")

                    # Log raw bytes for complete analysis
                    logger.debug(f"RAW_BYTES: {[hex(b) for b in user_input]} decimal={[b for b in user_input]}")

                    # Check for capture hotkey (Ctrl+E)
                    if CAPTURE_HOTKEY in user_input:
                        logger.debug("CAPTURE_HOTKEY detected - entering capture mode")
                        # Split input around hotkey to preserve other characters
                        prefix, _, suffix = user_input.partition(CAPTURE_HOTKEY)
                        if prefix:
                            logger.debug(f"HOTKEY_PREFIX: {repr(prefix)}")
                            self.pty_process.write(prefix)
                        self._enter_capture_mode()  # Enter hint overlay mode
                        if suffix:
                            logger.debug(f"HOTKEY_SUFFIX: {repr(suffix)}")
                            self.pty_process.write(suffix)
                    else:
                        # Enhanced Enter key handling for vim compatibility
                        processed_input = user_input
                        if user_input in (b'\n', b'\r\n') and self.in_alt_screen:
                            # In vim alternative screen, try different Enter key approaches
                            logger.debug("VIM_ENTER_ACTUAL_CONVERSION: Trying vim-compatible Enter")
                            # Method 1: Send CR instead of LF (most common issue)
                            if user_input == b'\n':
                                processed_input = b'\r'
                                logger.debug("VIM_ENTER_METHOD: LF -> CR conversion")
                            # Method 2: Send both CR+LF for maximum compatibility
                            elif user_input == b'\r\n':
                                processed_input = b'\r'  # Simplify to just CR
                                logger.debug("VIM_ENTER_METHOD: CRLF -> CR conversion")
                        elif user_input == b'\r' and self.in_alt_screen:
                            # CR is already correct for vim, keep as-is
                            logger.debug("VIM_ENTER_METHOD: CR passed through unchanged")

                        # Forward input (potentially modified) to shell
                        logger.debug(f"FORWARDING_INPUT to PTY: {repr(processed_input)}")
                        self.pty_process.write(processed_input)
                except OSError: break

            # Handle shell output
            if pty_fd in readable:
                try:
                    pty_output = self.pty_process.read()
                    if not pty_output: break  # EOF

                    # Decode and log the raw output
                    decoded_output = pty_output.decode('utf-8', 'replace')
                    logger.debug(f"PTY_OUTPUT: {repr(decoded_output)}")

                    # Log ANSI escape sequences specifically
                    ansi_sequences = re.findall(r'\x1b\[[?0-9;]*[a-zA-Z]', decoded_output)
                    if ansi_sequences:
                        logger.debug(f"ANSI_SEQUENCES: {ansi_sequences}")

                    # Check for vim mode changes or file opening indicators
                    if 'NERD_tree' in decoded_output:
                        logger.debug("VIM_NERDTREE: NERDTree interface detected")
                    if any(pattern in decoded_output for pattern in ['[No Name]', '.log', '.md', '.py']):
                        logger.debug(f"VIM_FILE_INDICATOR: Possible file name detected in output")
                    if '[New File]' in decoded_output or '[readonly]' in decoded_output:
                        logger.debug("VIM_FILE_OPENED: File opening indicator detected")
                    if any(mode in decoded_output for mode in ['-- INSERT --', '-- VISUAL --', '-- NORMAL --']):
                        logger.debug(f"VIM_MODE_CHANGE: Mode indicator detected in output")

                    # Handle alternative screen buffer sequences
                    self._handle_alt_screen_sequences(decoded_output)

                    # Feed output to pyte for terminal emulation
                    self.pyte_stream.feed(decoded_output)

                    # Log screen state changes
                    logger.debug(f"SCREEN_LINES: {self.pyte_screen.lines}, COLUMNS: {self.pyte_screen.columns}")
                    logger.debug(f"CURSOR_POS: ({self.pyte_screen.cursor.x}, {self.pyte_screen.cursor.y})")
                    logger.debug(f"DIRTY_LINES: {list(self.pyte_screen.dirty)}")

                except EOFError:
                    logger.debug("PTY_EOF: End of file from PTY process")
                    break

    def _handle_alt_screen_sequences(self, output: str):
        """Handle alternative screen buffer sequences for vim compatibility."""
        # Check for alternative screen buffer enable (\x1b[?1049h)
        if '\x1b[?1049h' in output:
            logger.debug("ALT_SCREEN_ENABLE: Entering alternative screen buffer")
            if not self.in_alt_screen:
                # Save current main screen content
                self.main_screen_content = self._capture_screen_state()
                self.in_alt_screen = True
                logger.debug("ALT_SCREEN_SAVED: Main screen content saved")

        # Check for alternative screen buffer disable (\x1b[?1049l)
        elif '\x1b[?1049l' in output:
            logger.debug("ALT_SCREEN_DISABLE: Exiting alternative screen buffer")
            if self.in_alt_screen and self.main_screen_content:
                # Restore main screen content
                self._restore_screen_state(self.main_screen_content)
                self.in_alt_screen = False
                logger.debug("ALT_SCREEN_RESTORED: Main screen content restored")

    def _capture_screen_state(self) -> dict:
        """Capture current screen state for later restoration."""
        return {
            'display': [self.pyte_screen.display[i] for i in range(self.pyte_screen.lines)],
            'buffer': [[self.pyte_screen.buffer[y][x] for x in range(self.pyte_screen.columns)]
                      for y in range(self.pyte_screen.lines)],
            'cursor_x': self.pyte_screen.cursor.x,
            'cursor_y': self.pyte_screen.cursor.y,
        }

    def _restore_screen_state(self, state: dict):
        """Restore screen state from captured state."""
        try:
            # Clear current screen
            self.pyte_screen.reset()

            # Restore buffer content
            for y in range(min(len(state['buffer']), self.pyte_screen.lines)):
                for x in range(min(len(state['buffer'][y]), self.pyte_screen.columns)):
                    self.pyte_screen.buffer[y][x] = state['buffer'][y][x]

            # Restore cursor position
            self.pyte_screen.cursor.x = state['cursor_x']
            self.pyte_screen.cursor.y = state['cursor_y']

            # Mark all lines as dirty for full redraw
            self.pyte_screen.dirty = set(range(self.pyte_screen.lines))

            logger.debug("SCREEN_STATE_RESTORED: Successfully restored main screen")
        except Exception as e:
            logger.error(f"SCREEN_RESTORE_ERROR: {e}")

    def _pyte_char_to_blessed(self, char: pyte_screens.Char) -> str:
        """
        Translates a pyte.Char's attributes into a blessed style string.
        This is the final, optimized version.
        """
        style = ""

        pyte_to_blessed_names = {
            'black': 'black', 'red': 'red', 'green': 'green', 'yellow': 'yellow',
            'blue': 'blue', 'magenta': 'magenta', 'cyan': 'cyan', 'white': 'white',
            'brightblack': 'bright_black', 'brightred': 'bright_red',
            'brightgreen': 'bright_green', 'brightyellow': 'bright_yellow',
            'brightblue': 'bright_blue', 'brightmagenta': 'bright_magenta',
            'brightcyan': 'bright_cyan', 'brightwhite': 'bright_white',
            'brown': 'yellow',  # FIX: Map 'brown' from pyte to blessed's 'yellow'.
        }

        def is_hex_color(s: str) -> bool:
            if s.startswith('#'): s = s[1:]
            return len(s) == 6 and all(c in '0123456789abcdefABCDEF' for c in s)

        # --- Foreground Color ---
        fg = str(char.fg)
        if fg in pyte_to_blessed_names:
            style += getattr(self.term, pyte_to_blessed_names[fg])
        # CORRECTED ORDER: Check for hex color *before* isdigit.
        elif is_hex_color(fg):
            hex_val = fg.lstrip('#')
            r, g, b = int(hex_val[0:2], 16), int(hex_val[2:4], 16), int(hex_val[4:6], 16)
            style += self.term.color_rgb(r, g, b)
        elif fg.isdigit():
            style += self.term.color(int(fg))

        # --- Background Color ---
        bg = str(char.bg)
        if bg in pyte_to_blessed_names:
            style += getattr(self.term, f"on_{pyte_to_blessed_names[bg]}")
        # CORRECTED ORDER: Check for hex color *before* isdigit.
        elif is_hex_color(bg):
            hex_val = bg.lstrip('#')
            r, g, b = int(hex_val[0:2], 16), int(hex_val[2:4], 16), int(hex_val[4:6], 16)
            style += self.term.on_color_rgb(r, g, b)
        elif bg.isdigit():
            style += self.term.on_color(int(bg))

        # --- Text Attributes ---
        if char.bold: style += self.term.bold
        if char.italics: style += self.term.italic
        if char.underscore: style += self.term.underline
        if char.reverse: style += self.term.reverse

        return style

    def _render(self, full=False):
        """Renders the pyte screen to the physical terminal using blessed."""
        lines_to_draw = range(self.pyte_screen.lines) if full else self.pyte_screen.dirty

        if not lines_to_draw and not self._flash_message_text and not full:
            if self.pyte_screen.cursor.hidden: print(self.term.hide_cursor(), end="")
            else: print(self.term.normal_cursor() + self.term.move_xy(self.pyte_screen.cursor.x, self.pyte_screen.cursor.y), end="")
            sys.stdout.flush()
            return

        with self.term.hidden_cursor():
            for y in lines_to_draw:
                line = self.pyte_screen.buffer[y]
                output_line = self.term.move_xy(0, y)
                current_style = "UNSET"
                segment = ""
                for x in range(self.pyte_screen.columns):
                    char = line[x]
                    style = self._pyte_char_to_blessed(char)

                    if style != current_style:
                        if segment:
                            output_line += self.term.normal + current_style + segment
                        segment = char.data
                        current_style = style
                    else:
                        segment += char.data

                if segment:
                    output_line += self.term.normal + current_style + segment

                output_line += self.term.clear_eol
                print(output_line, end="")

            self.pyte_screen.dirty.clear()

        if not self.pyte_screen.cursor.hidden:
            print(self.term.normal_cursor() + self.term.move_xy(self.pyte_screen.cursor.x, self.pyte_screen.cursor.y), end="")
        sys.stdout.flush()


    def _get_rendered_lines(self) -> List[str]:
        """Builds a list of fully rendered, colored screen lines from the pyte buffer."""
        rendered_lines = []
        for y in range(self.pyte_screen.lines):
            line = self.pyte_screen.buffer[y]
            output_line = ""
            current_style = "UNSET"
            segment = ""
            for x in range(self.pyte_screen.columns):
                char = line[x]
                style = self._pyte_char_to_blessed(char)
                if style != current_style:
                    if segment:
                        output_line += self.term.normal + current_style + segment
                    segment = char.data
                    current_style = style
                else:
                    segment += char.data
            if segment:
                output_line += self.term.normal + current_style + segment
            rendered_lines.append(output_line)
        return rendered_lines

    def _enter_capture_mode(self):
        """
        Enter capture mode with hint overlays for pattern selection.

        This method:
        1. Captures current screen content (both plain text and styled)
        2. Creates CaptureUI for interactive hint-based selection
        3. Copies selected text to clipboard and shows status feedback
        """
        logger.debug("=== CAPTURE_MODE_START ===")

        time.sleep(0.05)         # Brief pause to ensure screen is stable
        self._render(full=True)  # Force complete screen refresh

        # Extract screen content in two formats:
        # 1. Plain text for pattern matching
        plain_lines = [self.pyte_screen.display[i].rstrip() for i in range(self.pyte_screen.lines)]
        logger.debug(f"PLAIN_LINES_COUNT: {len(plain_lines)}")
        logger.debug(f"PLAIN_CONTENT_SAMPLE: {repr(plain_lines[:3])}")

        # 2. Colored/styled text for display
        colored_lines = self._get_rendered_lines()
        logger.debug(f"COLORED_LINES_COUNT: {len(colored_lines)}")

        # Launch interactive capture UI
        capture_app = CaptureUI(self.term, plain_lines, colored_lines)
        logger.debug(f"MATCHES_FOUND: {len(capture_app.matches)}")

        selected_text = capture_app.run()
        logger.debug(f"SELECTED_TEXT: {repr(selected_text)}")

        # Restore normal display and handle selection result
        self._render(full=True)
        logger.debug("CAPTURE_MODE_SCREEN_RESTORED")

        if selected_text:
            if copy_to_clipboard(selected_text):
                logger.debug(f"CLIPBOARD_SUCCESS: {repr(selected_text[:50])}")
                self._flash(f"Copied: {selected_text[:50]}")
            else:
                logger.debug("CLIPBOARD_FAILED")
                self._flash("Failed to copy to clipboard")

        logger.debug("=== CAPTURE_MODE_END ===")

    def _flash(self, message: str, duration: float = 1.2):
        self._flash_message_text = message
        self._flash_message_expires = time.time() + duration

def main():
    """
    Entry point for shell-capture application.

    Usage:
        shell-capture [command]    # Run specific command in capture wrapper
        shell-capture              # Start default shell in capture wrapper

    Controls:
        Ctrl+E                     # Enter capture mode (hint overlay)
        [hint keys]                # Select pattern in capture mode
        Escape/Ctrl+C              # Exit capture mode
        All other input            # Transparent pass-through to shell
    """
    # Parse command line arguments
    command = ' '.join(sys.argv[1:]) if len(sys.argv) > 1 else DEFAULT_SHELL

    logger.info(f"MAIN_START: args={sys.argv}, command={command}")

    # Create and run the TUI application
    app = ShellCaptureTUI(command)
    try:
        app.run()
    except KeyboardInterrupt:
        logger.info("MAIN_INTERRUPTED: KeyboardInterrupt")
        pass  # Clean exit on Ctrl+C
    except Exception as e:
        logger.error(f"MAIN_EXCEPTION: {e}")
        import traceback
        logger.error(f"MAIN_TRACEBACK: {traceback.format_exc()}")
        # Ensure terminal state is restored before printing traceback
        print(blessed.Terminal().normal)
        traceback.print_exc()
    finally:
        logger.info("MAIN_END")

if __name__ == "__main__":
    main()
